#include <windows.h>
#include <glad/gl.h>
#include <glad/wgl.h>
#include <iostream>

int main() {
    // 1. 创建隐藏窗口（dummy window）
    WNDCLASSA wc = {0};
    wc.lpfnWndProc = DefWindowProcA;
    wc.hInstance = GetModuleHandle(nullptr);
    wc.lpszClassName = "Dummy_WGL";
    RegisterClassA(&wc);
    HWND hwnd = CreateWindowA("Dummy_WGL", "Dummy OpenGL Window", 0,
                              CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                              nullptr, nullptr, wc.hInstance, nullptr);
    HDC hdc = GetDC(hwnd);

    // 2. 设置像素格式
    PIXELFORMATDESCRIPTOR pfd = {0};
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cDepthBits = 24;
    pfd.iLayerType = PFD_MAIN_PLANE;
    int pf = ChoosePixelFormat(hdc, &pfd);
    SetPixelFormat(hdc, pf, &pfd);

    // 3. 创建 dummy OpenGL context
    HGLRC tempContext = wglCreateContext(hdc);
    wglMakeCurrent(hdc, tempContext);

    // 4. 加载 WGL 扩展
    if (!gladLoaderLoadWGL(hdc)) {
        std::cerr << "Failed to load WGL extensions\n";
        return -1;
    }

    // 5. 创建 PBuffer
    int pbufferAttribs[] = {0};
    int pixelFormatAttribs[] = {
        WGL_DRAW_TO_PBUFFER_ARB, GL_TRUE,
        WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
        WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
        WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
        WGL_COLOR_BITS_ARB, 24,
        WGL_DEPTH_BITS_ARB, 24,
        0
    };
    int pixelFormatPbuffer = 0;
    UINT numFormats = 0;
    wglChoosePixelFormatARB(hdc, pixelFormatAttribs, nullptr, 1, &pixelFormatPbuffer, &numFormats);

    HPBUFFERARB pbuffer = wglCreatePbufferARB(hdc, pixelFormatPbuffer, 256, 256, pbufferAttribs);
    HDC pbufferDC = wglGetPbufferDCARB(pbuffer);

    // 6. 创建 OpenGL context on PBuffer
    int ctxAttribs[] = {
        WGL_CONTEXT_MAJOR_VERSION_ARB, 4,
        WGL_CONTEXT_MINOR_VERSION_ARB, 6,
        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_DEBUG_BIT_ARB,
        0
    };
    HGLRC pbufferContext = wglCreateContextAttribsARB(pbufferDC, nullptr, ctxAttribs);

    // 7. 切换到 PBuffer context
    wglMakeCurrent(pbufferDC, pbufferContext);

    // 立即销毁 dummy context 和窗口资源
    wglDeleteContext(tempContext);
    ReleaseDC(hwnd, hdc);
    DestroyWindow(hwnd);

    // 8. 加载 OpenGL 函数
    if (!gladLoaderLoadGL()) {
        std::cerr << "Failed to load OpenGL functions\n";
        return -1;
    }

    // 9. 测试 OpenGL
    std::cout << "OpenGL Version: " << glGetString(GL_VERSION) << std::endl;

    // 10. 清理
    wglMakeCurrent(nullptr, nullptr);

    // 7. 切换到 PBuffer context
    wglMakeCurrent(pbufferDC, pbufferContext);

    wglDeleteContext(pbufferContext);
    wglReleasePbufferDCARB(pbuffer, pbufferDC);
    wglDestroyPbufferARB(pbuffer);

    return 0;
}