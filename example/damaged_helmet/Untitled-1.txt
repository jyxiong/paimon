#version 460 core\n// --- Begin include: pbr.glsl ---\n// PBR (Physically Based Rendering) common functions\n// Based on Cook-Torrance BRDF\n\n#ifndef PBR_GLSL\n#define PBR_GLSL\n\nconst float PI = 3.14159265359;\n\n// Fresnel-Schlick approximation\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n// GGX/Trowbridge-Reitz normal distribution function\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float NdotH = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH * NdotH;\n\n  float nom = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return nom / max(denom, 0.0001);\n}\n\n// Schlick-GGX geometry function (single direction)\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n\n  float nom = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / max(denom, 0.0001);\n}\n\n// Smith's method for geometry obstruction\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\n// Calculate PBR lighting for a single light source\n// Returns the contribution from this light\nvec3 calculatePBRLighting(\n  vec3 N,", ' ' <repeats 11 times>, "// Normal\n  vec3 V,", ' ' <repeats 11 times>, "// View direction\n  vec3 L,", ' ' <repeats 11 times>, "// Light direction\n  vec3 albedo,      // Base color\n  float metallic,   // Metallic value\n  float roughness,  // Roughness value\n  vec3 radiance     // Light color/intensity\n)\n{\n  vec3 H = normalize(V + L);\n\n  // Calculate reflectance at normal incidence\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, albedo, metallic);\n\n  // Cook-Torrance BRDF\n  float NDF = DistributionGGX(N, H, roughness);\n  float G = GeometrySmith(N, V, L, roughness);\n  vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n\n  vec3 numerator = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n  vec3 specular = numerator / denominator;\n\n  // Energy conservation: kS + kD = 1.0\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - metallic; // Metallic surfaces don't have diffuse\n\n  float NdotL = max(dot(N, L), 0.0);\n\n  return (kD * albedo / PI + specular) * radiance * NdotL;\n}\n\n#endif // PBR_GLSL\n// --- End include: pbr.glsl ---\nin vec3 v_position;\nin vec3 v_normal;\nin vec2 v_texcoord;\n\nout vec4 FragColor;\n\nuniform sampler2D u_baseColorTexture;\nuniform sampler2D u_metallicRoughnessTexture;\nuniform sampler2D u_normalTexture;\nuniform sampler2D u_emissiveTexture;\nuniform sampler2D u_occlusionTexture;\n\nuniform vec4 u_baseColorFactor;\nuniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec3 u_emissiveFactor;\n\nuniform vec3 u_lightPos;\nuniform vec3 u_viewPos;\n\nvoid main()\n{\n  // Sample textures\n  vec4 baseColor = texture(u_baseColorTexture, v_texcoord) * u_baseColorFactor;\n  vec4 metallicRoughness = texture(u_metallicRoughnessTexture, v_texcoord);\n  float metallic = metallicRoughness.b * u_metallicFactor;\n  float roughness = metallicRoughness.g * u_roughnessFactor;\n  vec3 emissive = texture(u_emissiveTexture, v_texcoord).rgb * u_emissiveFactor;\n  float ao = texture(u_occlusionTexture, v_texcoord).r;\n\n  // Normal from normal map\n  vec3 N = normalize(v_normal);\n  vec3 V = normalize(u_viewPos - v_position);\n  vec3 L = normalize(u_lightPos - v_position);\n\n  // Calculate PBR lighting\n  vec3 radiance = vec3(1.0); // Light color/intensity\n  vec3 Lo = calculatePBRLighting(N, V, L, baseColor.rgb, metallic, roughness, radiance);\n\n  // Ambient lighting (simplified)\n  vec3 ambient = vec3(0.03) * baseColor.rgb * ao;\n\n  vec3 color = ambient + Lo + emissive;\n\n  // Tone mapping (simple Reinhard)\n  color = color / (color + vec3(1.0));\n  // Gamma correction\n  color = pow(color, vec3(1.0 / 2.2));\n\n  FragColor = vec4(color, baseColor.a);\n}\n